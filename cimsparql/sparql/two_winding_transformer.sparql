# Name: Two winding transformer
PREFIX cim: <${cim}>
PREFIX SN: <${SN}>
PREFIX xsd: <${xsd}>
select
  # max(?mrid) returns the mrid of the primary winding
  (max(?mrid) as ?mrid)
  (max(?name) as ?name)
  (max(?bidzone) as ?bidzone_1)
  (max(?bidzone) as ?bidzone_2)
  (max(?node_1) as ?node_1)
  (max(?node_2) as ?node_2)
  (if (xsd:double(max(?p_1)) < xsd:double(max(?p_2)), xsd:double(max(?p_1)) + xsd:double(max(?p_2)), xsd:double(0.0)) as ?ploss_1)
  (if (xsd:double(max(?p_1)) > xsd:double(max(?p_2)), xsd:double(max(?p_1)) + xsd:double(max(?p_2)), xsd:double(0.0)) as ?ploss_2)
  (sum(xsd:double(str(?r))) as ?r)
  (max(?rate) as ?rate)
  (coalesce(max(?in_service), max(?connected_1) && max(?connected_2), True) as ?status)

  # Since the mrid is for winding 1, set un_1 as ?un
  (xsd:double(max(?un_1)) as ?un)
  (sum(xsd:double(str(?x))) as ?x)
  (sum(xsd:double(str(?b))) as ?b)
  (sum(xsd:double(str(?g))) as ?g)
  (sum(?angle) as ?angle)
  #  ratio: n = Us / Up (secondary (2) / primary (1))
  ((xsd:double(max(?ubase_2)) / xsd:double(max(?un_2))) / (xsd:double(max(?ubase_1)) / xsd:double(max(?un_1))) as ?ratio)
where
{
  service <${eq_repo}> {
    ?winding cim:TransformerEnd.Terminal ?terminal;
              cim:PowerTransformerEnd.ratedU ?ubase;
              cim:PowerTransformerEnd.PowerTransformer ?p_transformer;
              cim:PowerTransformerEnd.r ?r;
              cim:PowerTransformerEnd.x ?x;
              cim:PowerTransformerEnd.b ?b;
              cim:PowerTransformerEnd.g ?g;
              cim:IdentifiedObject.mRID ?w_mrid;
              cim:TransformerEnd.endNumber ?nr .
      optional{?winding cim:PowerTransformerEnd.phaseAngleClock ?aclock .}
      ?terminal cim:IdentifiedObject.mRID ?t_mrid;
               cim:Terminal.ConnectivityNode ?con_node .
      ?con_node cim:ConnectivityNode.ConnectivityNodeContainer/cim:VoltageLevel.BaseVoltage/cim:BaseVoltage.nominalVoltage ?un .
      ?p_transformer cim:IdentifiedObject.name ?name;
           cim:Equipment.EquipmentContainer ?substation;
           cim:Equipment.EquipmentContainer/cim:Substation.Region/cim:SubGeographicalRegion.Region/cim:IdentifiedObject.name ?area .
      optional {
        ?p_lim cim:OperationalLimit.OperationalLimitSet/cim:OperationalLimitSet.Terminal ?terminal;
               a cim:ActivePowerLimit;
               cim:IdentifiedObject.name '${rate}';
               cim:ActivePowerLimit.value ?w_rate
      } .
      optional {?substation SN:Substation.MarketDeliveryPoint/SN:MarketDeliveryPoint.BiddingArea/SN:BiddingArea.marketCode ?bidzone} .
      optional {?p_transformer SN:Equipment.networkAnalysisEnable ?network_analysis .}
      filter(regex(?area, '${region}'))
  }
  ?terminal cim:ACDCTerminal.connected ?connected .
  optional {?con_node cim:ConnectivityNode.TopologicalNode/cim:IdentifiedObject.mRID ?con_top_node_mrid .}
  optional {?terminal cim:Terminal.TopologicalNode/cim:IdentifiedObject.mRID ?term_top_node_mrid .}
  optional {?terminal ^cim:SvPowerFlow.Terminal/cim:SvPowerFlow.p ?p .}
  optional {?p_transformer ^cim:SvStatus.ConductingEquipment/cim:SvStatus.inService ?in_service .}

  # Assign mRID to ?node. Use the first existing
  # 1) mRID of the topological node associated with the connectivity node for each terminal
  # 2) mRID of the topological node associated with the terminal
  bind(coalesce(?con_top_node_mrid, ?term_top_node_mrid) as ?node)

  # Only include results where a connection to a topological node exists
  filter(?node)

  # Winding properties should be extracted only for winding 1. Set the value for winding 2 to 0.0, such that max
  # aggregation will pick the value for winding 1
  bind(if(?nr = 1, ?w_mrid, '') as ?mrid)

  # Create variables for node 1 and node 2
  bind(if(?nr = 1, str(?p), '') as ?p_1)
  bind(if(?nr = 1, ?node, '') as ?node_1)
  bind(if(?nr = 1, ?connected, False) as ?connected_1)
  bind(if(?nr = 1, str(?un), '') as ?un_1)
  bind(if(?nr = 1, str(?ubase), '') as ?ubase_1)
  bind(if(?nr = 2, str(?p), '') as ?p_2)
  bind(if(?nr = 2, ?node, '') as ?node_2)
  bind(if(?nr = 2, ?connected, False) as ?connected_2)
  bind(if(?nr = 2, str(?un), '') as ?un_2)
  bind(if(?nr = 2, str(?ubase), '') as ?ubase_2)

  # Extract only angle clock for winding 2 (set to 0 for winding 1)
  bind(xsd:double(30.0) * coalesce(?angleclock, 0.0) as ?angle)
} group by ?p_transformer
having ((count(*) = 2) && coalesce(max(?analysis_enabled), True))
